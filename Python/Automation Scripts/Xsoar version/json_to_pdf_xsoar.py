import json
import re
import io


class MinimalPDF:
    """
    A minimal PDF generator that allows for basic text rendering, page management, 
    and metadata handling. This class supports dynamic margins, text wrapping, and
    simple table-like structures. It is designed to create a PDF document with
    customizable dimensions and margins, and provides methods to add text, headers,
    and rows with dynamic column widths. The generated PDF can be saved to a file or
    returned as a binary stream.
    It is suitable for generating simple PDF documents programmatically.
    The PDF version is set to 1.4, and the class does not depend on any external 
    libraries for PDF generation, making it lightweight and easy to use for basic 
    PDF creation tasks.
    """

    def __init__(self, filename, page_width=595, page_height=842, margin=50):
        self.filename = filename
        self.page_width = page_width
        self.page_height = page_height
        self.margin = margin
        self.objects = []
        self.pages = []
        self.current_content = ""
        self.y = page_height - margin
        self.font_size = 12
        self.leading = 16  # Line height
        self.char_width = 7  # Approximate width for Helvetica 12pt
        self.metadata = self.generate_default_metadata()

    def generate_default_metadata(self):
        """
        :description: This method initializes the PDF metadata with default values.
        :return: A dictionary containing default metadata for the PDF.
        :example: 
        {
            "Title": "Untitled PDF",
            "Author": "Generated by MinimalPDF",
            "Producer": "MinimalPDF Python",
            "PageCount": 0,
            "PDFVersion": "1.4",
            "CustomMetadata": "No",
            "Tagged": "No",
            "Encrypted": "No"
        }
        """

        return {
            "Title": "Untitled PDF",
            "Author": "Generated by MinimalPDF",
            "Producer": "MinimalPDF Python",
            "PageCount": 0,
            "PDFVersion": "1.4",
            "CustomMetadata": "No",
            "Tagged": "No",
            "Encrypted": "No",
        }

    def set_metadata(self, key, value):
        """
        :description: Sets a custom metadata field for the PDF document.
        :param key: The metadata field name (e.g., "Title", "Author").
        :param value: The value for the metadata field.
        :return: None
        :example:
        pdf.set_metadata("Title", "My Custom PDF")
        """

        self.metadata[key] = value

    def set_margin(self, margin):
        """
        :description: Sets the margin for the PDF document. The margin is applied
            to all sides of the page.
        :param margin: The margin size in points.
        :return: None
        :example:
        pdf.set_margin(30) 
        """

        self.margin = margin
        # Reset the vertical position based on the new margin
        self.y = self.page_height - margin

    def get_usable_width(self):
        """
        :description: Calculates the usable width of the PDF page, which is the total
            page width minus the left and right margins.
        :return: The usable width in points.
        :example:
        usable_width = pdf.get_usable_width()
        """

        return self.page_width - 2 * self.margin

    def add_page(self):
        """
        :description: Adds a new page to the PDF document. This method resets the
            current content and vertical position, and draws a border around the new page.
        :return: None
        :example:
        pdf.add_page()
        """

        if self.current_content:
            self.pages.append(self.current_content)
            self.current_content = ""

        self.y = self.page_height - self.margin - self.leading
        self.draw_page_border()

    def set_font(self, size):
        """
        :description: Sets the font size for the PDF document. This affects the
            text rendering size and line height.
        :param size: The font size in points.
        :return: None
        :example:
        pdf.set_font(12)
        """

        self.font_size = size
        self.leading = int(size * 1.3)
        self.char_width = int(size * 0.6)

    def text(self, x, y, txt):
        """
        :description: Places text at a specific position on the PDF page.
        :param x: The x-coordinate for the text position.
        :param y: The y-coordinate for the text position.
        :param txt: The text to be placed at the specified position.
        :return: None
        :example:
        pdf.text(100, 200, "Hello, World!")
        """

        self.current_content += f"BT /F1 {self.font_size} Tf {x} {y} Td ({self._escape(txt)}) Tj ET\n"

    def wrap_text(self, txt, max_width):
        """
        :description: Wraps text to fit within a specified width, breaking it
            into lines based on word boundaries.
        :param txt: The text to be wrapped.
        :param max_width: The maximum width in points for each line of text.
        :return: A list of strings, each representing a line of wrapped text.
        :example:
        wrapped_lines = pdf.wrap_text("This is a long text that needs to be wrapped.", 200) 
        """

        max_chars = max(int(max_width // self.char_width), 1)
        # 200 // 7 => 28 characters max per line. If division results in less than 1, set to 1.

        words = txt.split()
        lines = []
        current = ""
        for word in words:
            if len(current) + len(word) + 1 > max_chars:
                # If adding the next word + space exceeds the max width, save the current line
                # and start a new line with the current word
                if current:
                    lines.append(current)
                current = word
            else:
                if current:
                    # If current line is not empty, add the word with a space
                    current += " " + word
                else:
                    # If current line is empty, just set it to the word
                    current = word
        if current:
            # If there's any remaining text in current, add it as the last line
            lines.append(current)
        return lines

    def draw_separator(self, columns, divider=" | "):
        """
        :description: Draws a horizontal separator line for each column in a table-like structure.
        :param columns: List of tuples [(col_x, col_width), ...] defining column positions and widths.
        :param divider: The divider string between columns.
        :return: None
        :example:
        pdf.draw_separator([(50, 100), (200, 150), (400, 100)])
        """

        for i, (col_x, col_width) in enumerate(columns):
            # divide total column width by width of a character to know how many characters fit in the
            # column width => 100 // 7 => 14 characters fit in the column width 100
            sep_len = col_width // self.char_width
            # "_" * 14 => "______________"
            self.text(col_x, self.y, "_" * sep_len)

            if i < len(columns) - 1:
                # if this is not the last column, find the next column's x position and calculate the
                # length of the divider line to draw between this column and the next one
                # e.g., if current column is at 50 with width 100, next column is at 200 the divider
                # length will be (200 - (50 + 100)) // 7 -> 50 // 7 => 7 characters
                next_col_x = columns[i + 1][0]
                divider_len = (next_col_x - (col_x + col_width)
                               ) // self.char_width
                # draw a line of 7 underscores at the end of the current column
                self.text(col_x + col_width, self.y, "_" *
                          divider_len)  # 7 => "_______"

        # Move to the next line
        self.y -= self.leading
        if self.y < self.margin:
            # if margin is 50, y starts at 792(842 - 50) at the top, if y goes below 50, add a new page
            self.add_page()

    def draw_row(self, row_data, columns, divider=" | "):
        """
        :description: Draws a row of text in a table-like structure with specified columns.
        :param row_data: List of strings representing the data for each column in the row.
        :param columns: List of tuples [(col_x, col_width), ...] defining column positions and widths.
        :param divider: The divider string between columns.
        :return: None
        :example:
        pdf.draw_row(["Column 1", "Column 2"], [(40, 252), (302, 252)])
        """

        # Add padding to the left margin so that first column text does not touch the left border
        left_padding = 10

        # Loop through each data and column pair and wrap text so that it fits within the column width
        wrapped_columns = [
            self.wrap_text(data, col_width - left_padding) for data, (_, col_width) in zip(row_data, columns)
        ]
        # Find the column (line of text) which is the longest
        max_lines = max(len(lines) for lines in wrapped_columns)

        for i in range(max_lines):
            # Check if the current vertical position exceeds the margin and add a new page if necessary
            if self.y - self.leading < self.margin:
                self.add_page()

            for j, (col_x, col_width) in enumerate(columns):
                # If first column (j=0) add left padding to column x position so that text does not touch
                # the left border. 'text_x' will be the x position where text starts for each column.
                text_x = col_x + (left_padding if j == 0 else 0)
                # Add each sublist item to the column
                text = wrapped_columns[j][i] if i < len(
                    wrapped_columns[j]) else ""
                self.text(text_x, self.y, text)

                # Add divider if not the last column
                if j < len(columns) - 1:
                    self.text(col_x + col_width, self.y, divider)

            # Move to the next line
            self.y -= self.leading

            # Ensure the vertical position respects the margin
            if self.y < self.margin:
                self.add_page()

    def cell(self, w, h, txt):
        """
        :description: Draws a cell with specified width and height, wrapping text to fit within the cell.
        :param w: Width of the cell in points.
        :param h: Height of the cell in points.
        :param txt: The text to be placed inside the cell.
        :return: None
        :example:
        pdf.cell(100, 50, "This is a cell with wrapped text that fits within the specified width and height.")
        """
        # Add padding to the left margin so that text does not touch the left border
        left_padding = 10

        # Calculate the usable width for text within the cell
        # w is the width of the cell, margin is the left margin, and left_padding is added to ensure text
        # does not touch the border
        usable_width = w - self.margin - left_padding
        # Wrap the text to fit within the usable width
        wrapped_text = self.wrap_text(txt, usable_width)

        # Render each line of wrapped text within the cell
        for line in wrapped_text:
            # Adjust text position with padding and move y down to the next line
            self.text(self.margin + left_padding, self.y, line)
            self.y -= self.leading  # Move to the next line

        # After writing a line to cell, calculate remaining height in cell
        self.y -= h - (len(wrapped_text) * self.leading)

        # Add a new page if the vertical position exceeds the margin
        if self.y < self.margin:
            self.add_page()

    def add_header(self, header_text):
        """
        :description: Adds a header to the current page with a centered title and a separator line.
        :param header_text: The text to be displayed in the header.
        :return: None
        :example:
        pdf.add_header("My Document Header")
        """
        # Store the current font size to restore later as it will be changed for the header
        old_font_size = self.font_size
        # Font size for the header set to 16 points
        self.set_font(16)

        # Render the header text centered within the usable width
        usable_width = self.get_usable_width()
        # Calculate the x position to center the header text
        header_x = self.margin + \
            (usable_width - len(header_text) * self.char_width) // 2
        # Calculate the y position for the header text
        header_y = self.page_height - self.margin - \
            self.leading  # Adjust Y to stay inside the border
        # Add the header text to the current content
        self.text(header_x, header_y, header_text)

        # Set the y position for the separator line below the header, x start and end positions
        separator_y = header_y - self.leading
        separator_start_x = self.margin
        separator_end_x = self.page_width - self.margin

        # Use pdf commands to draw the separator line below the header
        self.current_content += f"{separator_start_x} {separator_y} m {separator_end_x} {separator_y} l S\n"

        # Set y position for the next content below the separator
        self.y = separator_y - self.leading
        # Restore the original font size
        self.set_font(old_font_size)

        # Add a new page if the vertical position exceeds the margin
        if self.y < self.margin:
            self.add_page()

    def draw_page_border(self):
        """
        :description: Draws a rectangle border around the page using pdf commands, respecting the margins.
        :return: None
        :example:
        pdf.draw_page_border()
        """

        border_start_x = self.margin
        border_start_y = self.margin
        border_end_x = self.page_width - self.margin
        border_end_y = self.page_height - self.margin

        # Draw the rectangle border
        self.current_content += (
            f"{border_start_x} {border_start_y} m "
            f"{border_end_x} {border_start_y} l "
            f"{border_end_x} {border_end_y} l "
            f"{border_start_x} {border_end_y} l "
            f"h S\n"
        )

    def output(self):
        """
        :description: Generates the PDF content as a binary stream. This method compiles all
            the page content, metadata, and necessary PDF structure into a binary format.
        :return: A BytesIO object containing the PDF binary data.
        :example:
        bin_pdf = pdf.output()
        with open("output.pdf", "wb") as f:
            f.write(bin_pdf.getvalue())
        """

        if self.current_content:
            self.pages.append(self.current_content)

        pdf = io.BytesIO()
        pdf.write(b"%PDF-1.4\n")
        xref = [0]  # PDF spec: object 0 is always free
        obj_count = 1

        # Info object
        xref.append(pdf.tell())
        info_obj = obj_count
        info_dict = (f"{info_obj} 0 obj\n"
                     f"<< /Title ({self.metadata['Title']})\n"
                     f"/Author ({self.metadata['Author']})\n"
                     f"/Producer ({self.metadata['Producer']})\n"
                     f">>\nendobj\n")
        pdf.write(info_dict.encode())
        obj_count += 1

        # Font object
        xref.append(pdf.tell())
        font_obj = obj_count
        font = f"{font_obj} 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n"
        pdf.write(font.encode())
        obj_count += 1

        # Content streams
        content_objs = []
        for content in self.pages:
            xref.append(pdf.tell())
            content_obj = obj_count
            stream_bytes = content.encode()
            stream = (f"{content_obj} 0 obj\n<< /Length {len(stream_bytes)} >>\nstream\n").encode(
            ) + stream_bytes + b"\nendstream\nendobj\n"
            pdf.write(stream)
            content_objs.append(content_obj)
            obj_count += 1

        # Page objects
        page_objs = []
        for content_obj in content_objs:
            xref.append(pdf.tell())
            page_obj = obj_count
            page = (f"{page_obj} 0 obj\n"
                    f"<< /Type /Page /Parent {obj_count + 1} 0 R /MediaBox [0 0 {self.page_width} {self.page_height}] "
                    f"/Contents {content_obj} 0 R /Resources << /Font << /F1 {font_obj} 0 R >> >> >>\n"
                    f"endobj\n")
            pdf.write(page.encode())
            page_objs.append(page_obj)
            obj_count += 1

        # Pages root object
        xref.append(pdf.tell())
        pages_obj = obj_count
        kids = " ".join([f"{p} 0 R" for p in page_objs])
        pages = (f"{pages_obj} 0 obj\n"
                 f"<< /Type /Pages /Kids [{kids}] /Count {len(page_objs)} >>\n"
                 f"endobj\n")
        pdf.write(pages.encode())
        obj_count += 1

        # Catalog object
        xref.append(pdf.tell())
        catalog_obj = obj_count
        catalog = (f"{catalog_obj} 0 obj\n"
                   f"<< /Type /Catalog /Pages {pages_obj} 0 R >>\n"
                   f"endobj\n")
        pdf.write(catalog.encode())
        obj_count += 1

        # Write xref table
        xref_start = pdf.tell()
        pdf.write(f"xref\n0 {obj_count}\n".encode())
        for offset in xref:
            pdf.write(f"{offset:010} 00000 n \n".encode())

        # Write trailer
        pdf.write(
            (f"trailer\n<< /Size {obj_count} /Root {catalog_obj} 0 R /Info {info_obj} 0 R >>\n"
             f"startxref\n{xref_start}\n%%EOF\n").encode()
        )
        pdf.seek(0)
        return pdf

    def _escape(self, txt):
        """
        :description: Escapes special characters in the text to ensure it is correctly formatted for PDF output.
        :param txt: The text to be escaped.
        :return: The escaped text.
        :example:
        escaped_text = pdf._escape("This is a (test) with special characters like \\ and ()")
        """

        return txt.replace("\\", "\\\\").replace("(", "\\(").replace(")", "\\)")


def process_json_object(object_match, pdf, column_width, spacing):
    json_str = object_match.group(1)
    json_str = bytes(json_str, "utf-8").decode("unicode_escape")
    data = json.loads(json_str)
    rows = []
    # If "Commands" key exists, flatten its contents
    if isinstance(data, dict) and "Commands" in data:
        for cmd in data["Commands"]:
            for k, v in cmd.items():
                if k == "Output":
                    idx = str(v).find('index:')
                    if idx != -1:
                        v = str(v)[:idx].strip()
                rows.append([k.lower(), str(v)])
        for k, v in data.items():
            if k != "Commands":
                rows.append([k.lower(), str(v)])
        columns = [
            (pdf.margin, column_width),
            (pdf.margin + column_width + spacing, column_width),
        ]
        divider = " | "
        for row in rows:
            pdf.draw_row(row, columns, divider=divider)
            pdf.draw_separator(columns, divider=divider)
        pdf.set_metadata("Title", "Keys and Values PDF")
        pdf.set_metadata("PageCount", len(pdf.pages))
        return pdf.output()
    else:
        print("Unsupported JSON structure.")
        return None


def process_json_array(array_str, pdf, column_width, label):
    array_str = bytes(array_str, "utf-8").decode("unicode_escape")
    try:
        data = json.loads(array_str)
    except Exception as e:
        print(f"Failed to parse JSON array: {e}")
        return None
    if not isinstance(data, list):
        print("Extracted value is not a JSON array.")
        return None

    columns = [
        (pdf.margin, column_width // 2),
        (pdf.margin + (column_width // 2) + 10, column_width // 2)
    ]
    divider = " | "

    # Only one row: label | all values
    value_str = ", ".join(str(item) for item in data)
    pdf.draw_row([label, value_str], columns, divider=divider)
    pdf.draw_separator(columns, divider=divider)

    pdf.set_metadata("Title", "Rules List PDF")
    pdf.set_metadata("PageCount", len(pdf.pages))
    return pdf.output()


def main():
    try:
        args = demisto.args()
        raw_input = args.get("input_text", "")
        if not raw_input:
            raw_input = next(iter(args.values()), "")
        if isinstance(raw_input, (dict, list)):
            raw_input = str(raw_input)
        raw_input = raw_input.replace('\r\n', '\n')

        object_pattern = r'Input="({.*})"'
        array_pattern = r'(".*?")\s+value="(\[.*?\])"(?:\s+regex=".*?")?'
        regex_extract_pattern = r'!RegexExtractAll\s+value="(\[.*?\])"(?:\s+regex=".*?")?'

        object_match = re.search(object_pattern, raw_input)
        array_match = re.search(array_pattern, raw_input)
        regex_extract_match = re.search(regex_extract_pattern, raw_input)

        filename = "output.pdf"
        pdf = MinimalPDF(filename)
        pdf.set_margin(40)
        pdf.set_font(9)
        pdf.draw_page_border()
        pdf.add_header("Keys and Values")

        usable_width = pdf.get_usable_width()
        spacing = 10
        column_width = (usable_width - spacing)

        if object_match:
            bin_pdf = process_json_object(
                object_match, pdf, column_width // 2, spacing)
            bin_pdf.seek(0)

            file_entry = fileResult(filename, bin_pdf.read())

            return_results(file_entry)
            return_results(CommandResults(
                outputs_prefix="ExtractedRulesPdf",
                outputs={
                    "EntryID": file_entry.get("FileID"),
                    "Name": filename
                }
            ))
        elif array_match:
            label = array_match.group(1).strip('"')
            array_str = array_match.group(2)
            bin_pdf = process_json_array(array_str, pdf, column_width, label)
            bin_pdf.seek(0)

            file_entry = fileResult(filename, bin_pdf.read())

            return_results(file_entry)
            return_results(CommandResults(
                outputs_prefix="ExtractedRulesPdf",
                outputs={
                    "EntryID": file_entry.get("FileID"),
                    "Name": filename
                }
            ))
        elif regex_extract_match:
            label = "RegexExtractAll"
            array_str = regex_extract_match.group(1)
            bin_pdf = process_json_array(array_str, pdf, column_width, label)
            bin_pdf.seek(0)

            file_entry = fileResult(filename, bin_pdf.read())

            return_results(file_entry)
            return_results(CommandResults(
                outputs_prefix="ExtractedRulesPdf",
                outputs={
                    "EntryID": file_entry.get("FileID"),
                    "Name": filename
                }
            ))
        else:
            print("No valid JSON object or array found in the input string")
    except Exception as e:
        print(f"An error occurred: {e}")


main()
