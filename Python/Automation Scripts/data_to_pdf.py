import re
import sys
import io


class MinimalPDF:
    """
    A minimal PDF generator that allows for basic text rendering, page management, 
    and metadata handling. This class supports dynamic margins, text wrapping, and
    simple table-like structures. It is designed to create a PDF document with
    customizable dimensions and margins, and provides methods to add text, headers,
    and rows with dynamic column widths. The generated PDF can be saved to a file or
    returned as a binary stream.
    It is suitable for generating simple PDF documents programmatically.
    The PDF version is set to 1.4, and the class does not depend on any external 
    libraries for PDF generation, making it lightweight and easy to use for basic 
    PDF creation tasks.
    """

    def __init__(self, filename, page_width=595, page_height=842, margin=50):
        """
        :description: MinimalPDF is a lightweight PDF generator that allows for basic text 
            rendering, page management, and metadata handling. It supports dynamic margins, text
            wrapping, and simple table-like structures. This class is designed to create a PDF
            document with customizable dimensions and margins. The default page size is A4 
            (595x842 points), and the default margin is 50 points.
        :param filename: The name of the PDF file to be created.
        :param page_width: Width of the PDF page in points (default is A4 width).
        :param page_height: Height of the PDF page in points (default is A4 height).
        :param margin: Margin size in points (default is 50 points).
        :return: None
        """

        # filename for metadata purposes
        self.filename = filename
        # page width in points
        self.page_width = page_width
        # page height in points
        self.page_height = page_height
        # page margin in points
        self.margin = margin
        # list to hold PDF objects
        self.objects = []
        # list to hold page content
        self.pages = []
        # current content being built for the page
        self.current_content = ""
        # current vertical position on the page, starting from the top
        self.y = page_height - margin
        # default font size in points, default(and only) font is Helvetica
        self.font_size = 12
        # (pronounced "ledding") line height, calculated as 1.3 times the font size
        self.leading = 16
        # character width, calculated as 0.6 times the font size
        self.char_width = 7
        # default metadata for the PDF
        self.metadata = self.generate_default_metadata()

    def generate_default_metadata(self):
        """
        :description: This method initializes the PDF metadata with default values.
        :return: A dictionary containing default metadata for the PDF.
        :example: 
        {
            "Title": "Untitled PDF",
            "Author": "Generated by MinimalPDF",
            "Producer": "MinimalPDF Python",
            "PageCount": 0,
            "PDFVersion": "1.4",
            "CustomMetadata": "No",
            "Tagged": "No",
            "Encrypted": "No"
        }
        """

        return {
            "Title": "Untitled PDF",
            "Author": "Generated by MinimalPDF",
            "Producer": "MinimalPDF Python",
            "PageCount": 0,
            "PDFVersion": "1.4",
            "CustomMetadata": "No",
            "Tagged": "No",
            "Encrypted": "No",
        }

    def set_metadata(self, key, value):
        """
        :description: Sets a custom metadata field for the PDF document.
        :param key: The metadata field name (e.g., "Title", "Author").
        :param value: The value for the metadata field.
        :return: None
        :example:
        pdf.set_metadata("Title", "My Custom PDF")
        """

        self.metadata[key] = value

    def set_margin(self, margin):
        """
        :description: Sets the margin for the PDF document. The margin is applied
            to all sides of the page.
        :param margin: The margin size in points.
        :return: None
        :example:
        pdf.set_margin(30) 
        """

        self.margin = margin
        self.y = self.page_height - margin

    def get_usable_width(self):
        """
        :description: Calculates the usable width of the PDF page, which is the total
            page width minus the left and right margins.
        :return: The usable width in points.
        :example:
        usable_width = pdf.get_usable_width()
        """

        return self.page_width - 2 * self.margin

    def add_page(self):
        """
        :description: Adds a new page to the PDF document. This method resets the
            current content and vertical position, and draws a border around the new page.
        :return: None
        :example:
        pdf.add_page()
        """

        if self.current_content:
            self.pages.append(self.current_content)
            self.current_content = ""

        self.y = self.page_height - self.margin - self.leading
        self.draw_page_border()

    def set_font(self, size):
        """
        :description: Sets the font size for the PDF document. This affects the
            text rendering size and line height.
        :param size: The font size in points.
        :return: None
        :example:
        pdf.set_font(12)
        """

        self.font_size = size
        self.leading = int(size * 1.3)
        self.char_width = int(size * 0.6)

    def text(self, x, y, txt):
        """
        :description: Places text at a specific position on the PDF page.
        :param x: The x-coordinate for the text position.
        :param y: The y-coordinate for the text position.
        :param txt: The text to be placed at the specified position.
        :return: None
        :example:
        pdf.text(100, 200, "Hello, World!")
        """

        self.current_content += f"BT /F1 {self.font_size} Tf {x} {y} Td ({self._escape(txt)}) Tj ET\n"

    def wrap_text(self, txt, max_width):
        """
        :description: Wraps text to fit within a specified width, breaking it
            into lines based on word boundaries.
        :param txt: The text to be wrapped.
        :param max_width: The maximum width in points for each line of text.
        :return: A list of strings, each representing a line of wrapped text.
        :example:
        wrapped_lines = pdf.wrap_text("This is a long text that needs to be wrapped.", 200) 
        """

        max_chars = max(int(max_width // self.char_width), 1)
        # 200 // 7 => 28 characters max per line. If division results in less than 1, set to 1.

        words = txt.split()
        lines = []
        current = ""
        for word in words:
            if len(current) + len(word) + 1 > max_chars:
                # If adding the next word + space exceeds the max width, save the current line
                # and start a new line with the current word
                if current:
                    lines.append(current)
                current = word
            else:
                if current:
                    # If current line is not empty, add the word with a space
                    current += " " + word
                else:
                    # If current line is empty, just set it to the word
                    current = word
        if current:
            # If there's any remaining text in current, add it as the last line
            lines.append(current)
        return lines

    def draw_separator(self, columns, divider=" | "):
        """
        :description: Draws a horizontal separator line for each column in a table-like structure.
        :param columns: List of tuples [(col_x, col_width), ...] defining column positions and widths.
        :param divider: The divider string between columns.
        :return: None
        :example:
        pdf.draw_separator([(50, 100), (200, 150), (400, 100)])
        """

        for i, (col_x, col_width) in enumerate(columns):
            # divide total column width by width of a character to know how many characters fit in the
            # column width => 100 // 7 => 14 characters fit in the column width 100
            sep_len = col_width // self.char_width
            # "_" * 14 => "______________"
            self.text(col_x, self.y, "_" * sep_len)

            if i < len(columns) - 1:
                # if this is not the last column, find the next column's x position and calculate the
                # length of the divider line to draw between this column and the next one
                # e.g., if current column is at 50 with width 100, next column is at 200 the divider
                # length will be (200 - (50 + 100)) // 7 -> 50 // 7 => 7 characters
                next_col_x = columns[i + 1][0]  # points to 200, 400
                divider_len = (next_col_x - (col_x + col_width)
                               ) // self.char_width
                # draw a line of 7 underscores at the end of the current column
                self.text(col_x + col_width, self.y, "_" *
                          divider_len)  # 7 => "_______"

        # Move to the next line
        self.y -= self.leading

        if self.y < self.margin:
            # if margin is 50, y starts at 792(842 - 50) at the top, if y goes below 50, add a new page
            self.add_page()

    def draw_row(self, row_data, columns, divider=" | "):
        """
        :description: Draws a row of text in a table-like structure with specified columns.
        :param row_data: List of strings representing the data for each column in the row.
        :param columns: List of tuples [(col_x, col_width), ...] defining column positions and widths.
        :param divider: The divider string between columns.
        :return: None
        :example:
        pdf.draw_row(["Column 1", "Column 2"], [(40, 252), (302, 252)])
        """

        # Add padding to the left margin so that first column text does not touch the left border
        left_padding = 10

        # Loop through each data and column pair and wrap text so that it fits within the column width
        wrapped_columns = [
            self.wrap_text(data, col_width - left_padding) for data, (_, col_width) in zip(row_data, columns)
        ]
        # Find the column (line of text) which is the longest
        max_lines = max(len(lines) for lines in wrapped_columns)

        for i in range(max_lines):
            # Check if the current vertical position exceeds the margin and add a new page if necessary
            if self.y - self.leading < self.margin:
                self.add_page()

            for j, (col_x, col_width) in enumerate(columns):
                # If first column (j=0) add left padding to column x position so that text does not touch
                # the left border. 'text_x' will be the x position where text starts for each column.
                text_x = col_x + (left_padding if j == 0 else 0)
                # Add each sublist item to the column
                text = wrapped_columns[j][i] if i < len(
                    wrapped_columns[j]) else ""
                self.text(text_x, self.y, text)

                # Add divider if not the last column
                if j < len(columns) - 1:
                    self.text(col_x + col_width, self.y, divider)

            # Move to the next line
            self.y -= self.leading

            # Ensure the vertical position respects the margin
            if self.y < self.margin:
                self.add_page()

    def cell(self, w, h, txt):
        """
        :description: Draws a cell with specified width and height, wrapping text to fit within the cell.
        :param w: Width of the cell in points.
        :param h: Height of the cell in points.
        :param txt: The text to be placed inside the cell.
        :return: None
        :example:
        pdf.cell(100, 50, "This is a cell with wrapped text that fits within the specified width and height.")
        """
        # Add padding to the left margin so that text does not touch the left border
        left_padding = 10

        # Calculate the usable width for text within the cell
        # w is the width of the cell, margin is the left margin, and left_padding is added to ensure text
        # does not touch the border
        usable_width = w - self.margin - left_padding
        # Wrap the text to fit within the usable width
        wrapped_text = self.wrap_text(txt, usable_width)

        # Render each line of wrapped text within the cell
        for line in wrapped_text:
            # Adjust text position with padding and move y down to the next line
            self.text(self.margin + left_padding, self.y, line)
            self.y -= self.leading

        # After writing a line to cell, calculate remaining height in cell
        self.y -= h - (len(wrapped_text) * self.leading)

        # Add a new page if the vertical position exceeds the margin
        if self.y < self.margin:
            self.add_page()

    def add_header(self, header_text):
        """
        :description: Adds a header to the current page with a centered title and a separator line.
        :param header_text: The text to be displayed in the header.
        :return: None
        :example:
        pdf.add_header("My Document Header")
        """
        # Store the current font size to restore later as it will be changed for the header
        old_font_size = self.font_size
        # Font size for the header set to 16 points
        self.set_font(16)

        # Render the header text centered within the usable width
        usable_width = self.get_usable_width()
        # Calculate the x position to center the header text
        header_x = self.margin + \
            (usable_width - len(header_text) * self.char_width) // 2
        # Calculate the y position for the header text
        header_y = self.page_height - self.margin - \
            self.leading
        # Add the header text to the current content
        self.text(header_x, header_y, header_text)

        # Set the y position for the separator line below the header, x start and end positions
        separator_y = header_y - self.leading
        separator_start_x = self.margin
        separator_end_x = self.page_width - self.margin

        # Use pdf commands to draw the separator line below the header
        self.current_content += f"{separator_start_x} {separator_y} m {separator_end_x} {separator_y} l S\n"

        # Set y position for the next content below the separator
        self.y = separator_y - self.leading
        # Restore the original font size
        self.set_font(old_font_size)

        # Add a new page if the vertical position exceeds the margin
        if self.y < self.margin:
            self.add_page()

    def draw_page_border(self):
        """
        :description: Draws a rectangle border around the page using pdf commands, respecting the margins.
        :return: None
        :example:
        pdf.draw_page_border()
        """
        border_start_x = self.margin
        border_start_y = self.margin
        border_end_x = self.page_width - self.margin
        border_end_y = self.page_height - self.margin

        # Draw the rectangle border
        self.current_content += (
            f"{border_start_x} {border_start_y} m "
            f"{border_end_x} {border_start_y} l "
            f"{border_end_x} {border_end_y} l "
            f"{border_start_x} {border_end_y} l "
            f"h S\n"
        )

    def output(self):
        """
        :description: Generates the PDF content as a binary stream. This method compiles all
            the page content, metadata, and necessary PDF structure into a binary format.
        :return: A BytesIO object containing the PDF binary data.
        :example:
        bin_pdf = pdf.output()
        with open("output.pdf", "wb") as f:
            f.write(bin_pdf.getvalue())
        """
        if self.current_content:
            self.pages.append(self.current_content)

        pdf = io.BytesIO()
        pdf.write(b"%PDF-1.4\n")
        xref = [0]  # PDF spec: object 0 is always free
        obj_count = 1

        # Info object
        xref.append(pdf.tell())
        info_obj = obj_count
        info_dict = (f"{info_obj} 0 obj\n"
                     f"<< /Title ({self.metadata['Title']})\n"
                     f"/Author ({self.metadata['Author']})\n"
                     f"/Producer ({self.metadata['Producer']})\n"
                     f">>\nendobj\n")
        pdf.write(info_dict.encode())
        obj_count += 1

        # Font object
        xref.append(pdf.tell())
        font_obj = obj_count
        font = f"{font_obj} 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n"
        pdf.write(font.encode())
        obj_count += 1

        # Content streams
        content_objs = []
        for content in self.pages:
            xref.append(pdf.tell())
            content_obj = obj_count
            stream_bytes = content.encode()
            stream = (f"{content_obj} 0 obj\n<< /Length {len(stream_bytes)} >>\nstream\n").encode(
            ) + stream_bytes + b"\nendstream\nendobj\n"
            pdf.write(stream)
            content_objs.append(content_obj)
            obj_count += 1

        # Page objects
        page_objs = []
        for content_obj in content_objs:
            xref.append(pdf.tell())
            page_obj = obj_count
            page = (f"{page_obj} 0 obj\n"
                    f"<< /Type /Page /Parent {obj_count + 1} 0 R /MediaBox [0 0 {self.page_width} {self.page_height}] "
                    f"/Contents {content_obj} 0 R /Resources << /Font << /F1 {font_obj} 0 R >> >> >>\n"
                    f"endobj\n")
            pdf.write(page.encode())
            page_objs.append(page_obj)
            obj_count += 1

        # Pages root object
        xref.append(pdf.tell())
        pages_obj = obj_count
        kids = " ".join([f"{p} 0 R" for p in page_objs])
        pages = (f"{pages_obj} 0 obj\n"
                 f"<< /Type /Pages /Kids [{kids}] /Count {len(page_objs)} >>\n"
                 f"endobj\n")
        pdf.write(pages.encode())
        obj_count += 1

        # Catalog object
        xref.append(pdf.tell())
        catalog_obj = obj_count
        catalog = (f"{catalog_obj} 0 obj\n"
                   f"<< /Type /Catalog /Pages {pages_obj} 0 R >>\n"
                   f"endobj\n")
        pdf.write(catalog.encode())
        obj_count += 1

        # Write xref table
        xref_start = pdf.tell()
        pdf.write(f"xref\n0 {obj_count}\n".encode())
        for offset in xref:
            pdf.write(f"{offset:010} 00000 n \n".encode())

        # Write trailer
        pdf.write(
            (f"trailer\n<< /Size {obj_count} /Root {catalog_obj} 0 R /Info {info_obj} 0 R >>\n"
             f"startxref\n{xref_start}\n%%EOF\n").encode()
        )
        pdf.seek(0)
        return pdf

    def _escape(self, txt):
        """
        :description: Escapes special characters in the text to ensure it is correctly formatted for PDF output.
        :param txt: The text to be escaped.
        :return: The escaped text.
        :example:
        escaped_text = pdf._escape("This is a (test) with special characters like \\ and ()")
        """
        return txt.replace("\\", "\\\\").replace("(", "\\(").replace(")", "\\)")


def read_stdin():
    # Read all input from stdin (no prompt)
    return sys.stdin.read()


def extract_rules(text):
    """
    Extract rules and their values from the input.
    Handles:
      - "Rules ..." value="[\"...\",\"...\"]"
      - Rules ... value=["...", "..."]
      - Rules ... =["...", "..."]
      - Rules ... - ["...", "..."]
      - Rules ... - ... (plain text)
      - Rules ... . ... (plain text)
    """
    extracted = []

    # Pattern for quoted or unquoted task and value
    pattern_value = r'(?:"([^"]+)"|(\bRules[^\s=:-]+.*?))\s+value\s*=\s*(?:"|\')\[(.*?)\](?:"|\')'
    # Pattern for unquoted list after = or -
    pattern_list = r'(Rules.*?)(?:=|-)\s*\[(.*?)\]'
    # Pattern for single value after dash or period
    pattern_single = r'(Rules.*?)(?:-|\.)(?!\s*\[)(.*?)(?=(?:Rules|$))'

    # First, extract all rules with quoted or unquoted value=
    for match in re.finditer(pattern_value, text, re.DOTALL):
        rule_desc = match.group(1) or match.group(2)
        values = match.group(3).replace('\\', '')
        result = ', '.join([v.strip().strip('"').strip("'")
                           for v in values.split(',')])
        extracted.append([rule_desc.strip(), result])

    # Remove already matched parts to avoid duplicates
    text = re.sub(pattern_value, '', text, flags=re.DOTALL)

    # Then, extract all rules with lists (excluding value=)
    for match in re.finditer(pattern_list, text, re.DOTALL):
        rule_desc = match.group(1).strip().rstrip('= -').strip()
        values = match.group(2).replace('\\', '')
        result = ', '.join([v.strip().strip('"').strip("'")
                           for v in values.split(',')])
        extracted.append([rule_desc, result])

    # Remove already matched parts to avoid duplicates
    text_cleaned = re.sub(pattern_list, '', text, flags=re.DOTALL)

    # Now extract single-value rules (not followed by [ ... ])
    for match in re.finditer(pattern_single, text_cleaned, re.DOTALL):
        rule_desc = match.group(1).strip().rstrip('= -').strip()
        value = match.group(2).strip().strip('.').strip()
        if value:
            extracted.append([rule_desc, value])

    return extracted


def create_text_pdf(data, filename):
    # Assumes data is a list of lists.
    pdf = MinimalPDF(filename)

    pdf.set_margin(40)
    pdf.set_font(9)
    pdf.draw_page_border()
    pdf.add_header("Keys and Values")

    # Calculate usable width dynamically based on margins
    usable_width = pdf.get_usable_width()
    # Define spacing between columns
    spacing = 10
    # Adjust column widths to fit within usable width, including spacing
    column_width = (usable_width - spacing) // 2
    columns = [
        (pdf.margin, column_width),
        (pdf.margin + column_width + spacing, column_width),
    ]
    divider = " | "

    # Rows
    for row in data:
        # print(f"ROW: {row}\nCOLUMNS: {columns}")
        pdf.draw_row(row, columns, divider=divider)
        pdf.draw_separator(columns, divider=divider)

    # Set metadata
    pdf.set_metadata("Title", "Keys and Values PDF")
    pdf.set_metadata("PageCount", len(pdf.pages))

    return pdf.output()


def main():
    try:
        input_text = read_stdin()
        if not input_text:
            print("No input provided.")

        rules = extract_rules(input_text)
        if rules:
            pdf_filename = "rules.pdf"
            bin_pdf = create_text_pdf(rules, pdf_filename)
            bin_pdf.seek(0)
            with open(pdf_filename, "wb") as f:
                f.write(bin_pdf.read())
            print(f"[Local Dev] Saved file: {pdf_filename}")
        else:
            print("No rules found in the input.")
    except Exception as e:
        print(f"Script failed: {str(e)}")


main()
