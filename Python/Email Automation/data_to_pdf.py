import re
import sys
import datetime
import io


class MinimalPDF:
    def __init__(self, filename, page_width=595, page_height=842, margin=50):
        self.filename = filename
        self.page_width = page_width
        self.page_height = page_height
        self.margin = margin
        self.objects = []
        self.pages = []
        self.current_content = ""
        self.y = page_height - margin
        self.font_size = 12
        self.leading = 16  # Line height
        self.char_width = 7  # Approximate width for Helvetica 12pt
        self.metadata = self.generate_default_metadata()

    def generate_default_metadata(self):
        now = datetime.datetime.now()
        return {
            "Title": "Untitled PDF",
            "Author": "Generated by MinimalPDF",
            "Producer": "MinimalPDF Python",
            "CreateDate": now.strftime("%Y-%m-%dT%H:%M:%S"),
            "ModifyDate": now.strftime("%Y-%m-%dT%H:%M:%S"),
            "PageCount": 0,
            "PDFVersion": "1.4",
            "CustomMetadata": "No",
            "Tagged": "No",
            "Encrypted": "No",
        }

    def set_metadata(self, key, value):
        """
        Set custom metadata key-value pairs.
        :param key: Metadata field name.
        :param value: Metadata field value.
        """
        self.metadata[key] = value

    def set_margin(self, margin):
        """
        Sets the page margin dynamically.
        :param margin: The new margin value.
        """
        self.margin = margin
        # Reset the vertical position based on the new margin
        self.y = self.page_height - margin

    def get_usable_width(self):
        """
        Calculates the usable width of the page based on the margins.
        :return: Usable width of the page.
        """
        return self.page_width - 2 * self.margin

    def add_page(self):
        """
        Adds a new page and ensures the page border is drawn.
        """
        if self.current_content:
            self.pages.append(self.current_content)
            self.current_content = ""

        # Reset vertical position to start below the top margin
        # Ensure content starts below the margin
        self.y = self.page_height - self.margin - self.leading

        # Draw the page border for the new page
        self.draw_page_border()

    def set_font(self, size):
        self.font_size = size
        self.leading = int(size * 1.3)
        # Approximate char width for Helvetica (in points)
        self.char_width = int(size * 0.6)

    def text(self, x, y, txt):
        self.current_content += f"BT /F1 {self.font_size} Tf {x} {y} Td ({self._escape(txt)}) Tj ET\n"

    def wrap_text(self, txt, max_width):
        # Estimate max chars per line
        max_chars = max(int(max_width // self.char_width), 1)
        words = txt.split()
        lines = []
        current = ""
        for word in words:
            if len(current) + len(word) + 1 > max_chars:
                if current:
                    lines.append(current)
                current = word
            else:
                if current:
                    current += " " + word
                else:
                    current = word
        if current:
            lines.append(current)
        return lines

    def draw_separator(self, columns, divider=" | "):
        """
        Draws a separator line dynamically based on the number of columns.
        :param columns: List of tuples [(col_x, col_width), ...] defining column positions and widths.
        :param divider: The divider string between columns.
        """
        for i, (col_x, col_width) in enumerate(columns):
            # Calculate separator length for the current column
            sep_len = col_width // self.char_width
            self.text(col_x, self.y, "_" * sep_len)

            # Add divider separator if not the last column
            if i < len(columns) - 1:
                next_col_x = columns[i + 1][0]
                divider_len = (next_col_x - (col_x + col_width)
                               ) // self.char_width
                self.text(col_x + col_width, self.y, "_" * divider_len)

        # Move to the next line
        self.y -= self.leading
        if self.y < self.margin:
            self.add_page()

    def draw_row(self, row_data, columns, divider=" | "):
        """
        Draws a row dynamically based on the number of columns.
        :param row_data: List of strings representing the data for each column.
        :param columns: List of tuples [(col_x, col_width), ...] defining column positions and widths.
        :param divider: The divider string between columns.
        """
        # Add padding to the left margin for cell content
        left_padding = 10

        # Wrap text for each column
        wrapped_columns = [
            self.wrap_text(data, col_width - left_padding) for data, (_, col_width) in zip(row_data, columns)
        ]
        max_lines = max(len(lines) for lines in wrapped_columns)

        for i in range(max_lines):
            # Check if the current vertical position exceeds the margin
            if self.y - self.leading < self.margin:
                self.add_page()

            for j, (col_x, col_width) in enumerate(columns):
                # Adjust column position with padding for the first column
                text_x = col_x + (left_padding if j == 0 else 0)
                text = wrapped_columns[j][i] if i < len(
                    wrapped_columns[j]) else ""
                self.text(text_x, self.y, text)

                # Add divider if not the last column
                if j < len(columns) - 1:
                    self.text(col_x + col_width, self.y, divider)

            # Move to the next line
            self.y -= self.leading

            # Ensure the vertical position respects the margin
            if self.y < self.margin:
                self.add_page()

    def cell(self, w, h, txt):
        """
        Places text in a single cell with specified width and height.
        :param w: Width of the cell.
        :param h: Height of the cell.
        :param txt: Text to be placed in the cell.
        """
        # Add padding to the left margin for cell content
        left_padding = 10

        # Calculate usable width for the text within the cell
        usable_width = w - self.margin - left_padding
        wrapped_text = self.wrap_text(txt, usable_width)

        # Render each line of wrapped text within the cell
        for line in wrapped_text:
            # Adjust text position with padding
            self.text(self.margin + left_padding, self.y, line)
            self.y -= self.leading  # Move to the next line

        # Adjust vertical position based on cell height
        self.y -= h - (len(wrapped_text) * self.leading)

        # Add a new page if the vertical position exceeds the margin
        if self.y < self.margin:
            self.add_page()

    def add_header(self, header_text):
        """
        Adds a header with a separator line below it, ensuring it stays inside the page border.
        :param header_text: The text for the header.
        """
        old_font_size = self.font_size
        self.set_font(16)  # Set font size for header

        # Render the header text centered within the usable width
        usable_width = self.get_usable_width()
        header_x = self.margin + \
            (usable_width - len(header_text) * self.char_width) // 2
        header_y = self.page_height - self.margin - \
            self.leading  # Adjust Y to stay inside the border
        self.text(header_x, header_y, header_text)

        # Move to the next line for the separator
        separator_y = header_y - self.leading
        separator_start_x = self.margin
        separator_end_x = self.page_width - self.margin

        # Draw the separator line spanning the entire usable width
        self.current_content += f"{separator_start_x} {separator_y} m {separator_end_x} {separator_y} l S\n"

        # Update the vertical position for subsequent content
        self.y = separator_y - self.leading
        self.set_font(old_font_size)  # Restore original font size

        # Add a new page if the vertical position exceeds the margin
        if self.y < self.margin:
            self.add_page()

    def draw_page_border(self):
        """
        Draws a border around the page based on the current margin.
        """
        border_start_x = self.margin
        border_start_y = self.margin
        border_end_x = self.page_width - self.margin
        border_end_y = self.page_height - self.margin

        # Draw the rectangle border
        self.current_content += (
            f"{border_start_x} {border_start_y} m "
            f"{border_end_x} {border_start_y} l "
            f"{border_end_x} {border_end_y} l "
            f"{border_start_x} {border_end_y} l "
            f"h S\n"
        )

    def output(self):
        if self.current_content:
            self.pages.append(self.current_content)
        pdf = io.BytesIO()
        pdf.write(b"%PDF-1.4\n")
        xref = []
        obj_count = 1

        # Info dictionary (standard metadata)
        xref.append(pdf.tell())
        info_obj = obj_count
        info_dict = (f"{info_obj} 0 obj\n"
                     f"<< /Title ({self.metadata['Title']})\n"
                     f"/Author ({self.metadata['Author']})\n"
                     f"/Producer ({self.metadata['Producer']})\n"
                     f"/CreationDate (D:{self.metadata['CreateDate'].replace('-', '').replace(':', '')})\n"
                     f"/ModDate (D:{self.metadata['ModifyDate'].replace('-', '').replace(':', '')})\n"
                     f">>\nendobj\n")
        pdf.write(info_dict.encode())
        obj_count += 1

        # Font object
        xref.append(pdf.tell())
        font_obj = obj_count
        font = f"{font_obj} 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n"
        pdf.write(font.encode())
        obj_count += 1

        # Page content objects
        content_objs = []
        for content in self.pages:
            xref.append(pdf.tell())
            content_obj = obj_count
            stream = f"{content_obj} 0 obj\n<< /Length {len(content.encode())} >>\nstream\n{content}endstream\nendobj\n"
            pdf.write(stream.encode())
            content_objs.append(content_obj)
            obj_count += 1

        # Page objects
        page_objs = []
        for idx, content_obj in enumerate(content_objs):
            xref.append(pdf.tell())
            page_obj = obj_count
            page = (f"{page_obj} 0 obj\n"
                    f"<< /Type /Page /Parent {obj_count + 1} 0 R /MediaBox [0 0 {self.page_width} {self.page_height}] "
                    f"/Contents {content_obj} 0 R /Resources << /Font << /F1 {font_obj} 0 R >> >> >>\n"
                    f"endobj\n")
            pdf.write(page.encode())
            page_objs.append(page_obj)
            obj_count += 1

        # Pages root object
        xref.append(pdf.tell())
        pages_obj = obj_count
        kids = " ".join([f"{p} 0 R" for p in page_objs])
        pages = (f"{pages_obj} 0 obj\n"
                 f"<< /Type /Pages /Kids [{kids}] /Count {len(page_objs)} >>\n"
                 f"endobj\n")
        pdf.write(pages.encode())
        obj_count += 1

        # Catalog object
        xref.append(pdf.tell())
        catalog_obj = obj_count
        catalog = (f"{catalog_obj} 0 obj\n"
                   f"<< /Type /Catalog /Pages {pages_obj} 0 R >>\n"
                   f"endobj\n")
        pdf.write(catalog.encode())
        obj_count += 1

        # Xref table
        xref_start = pdf.tell()
        pdf.write(b"xref\n0 %d\n0000000000 65535 f \n" % obj_count)
        for offset in xref:
            pdf.write(b"%010d 00000 n \n" % offset)

        # Trailer
        pdf.write(
            (f"trailer\n<< /Size {obj_count} /Root {catalog_obj} 0 R /Info {info_obj} 0 R >>\nstartxref\n{xref_start}\n%%EOF\n").encode())
        pdf.seek(0)  # Reset the stream position to the beginning
        return pdf

    def _escape(self, txt):
        return txt.replace("\\", "\\\\").replace("(", "\\(").replace(")", "\\)")


def read_stdin():
    # Read all input from stdin (no prompt)
    return sys.stdin.read()


def extract_rules(text):
    """
    Extract rules and their values from the input.
    Handles:
      - "Rules ..." value="[\"...\",\"...\"]"
      - Rules ... value=["...", "..."]
      - Rules ... =["...", "..."]
      - Rules ... - ["...", "..."]
      - Rules ... - ... (plain text)
      - Rules ... . ... (plain text)
    """
    extracted = []

    # Pattern for quoted or unquoted task and value
    pattern_value = r'(?:"([^"]+)"|(\bRules[^\s=:-]+.*?))\s+value\s*=\s*(?:"|\')\[(.*?)\](?:"|\')'
    # Pattern for unquoted list after = or -
    pattern_list = r'(Rules.*?)(?:=|-)\s*\[(.*?)\]'
    # Pattern for single value after dash or period
    pattern_single = r'(Rules.*?)(?:-|\.)(?!\s*\[)(.*?)(?=(?:Rules|$))'

    # First, extract all rules with quoted or unquoted value=
    for match in re.finditer(pattern_value, text, re.DOTALL):
        rule_desc = match.group(1) or match.group(2)
        values = match.group(3).replace('\\', '')
        result = ', '.join([v.strip().strip('"').strip("'")
                           for v in values.split(',')])
        extracted.append([rule_desc.strip(), result])

    # Remove already matched parts to avoid duplicates
    text = re.sub(pattern_value, '', text, flags=re.DOTALL)

    # Then, extract all rules with lists (excluding value=)
    for match in re.finditer(pattern_list, text, re.DOTALL):
        rule_desc = match.group(1).strip().rstrip('= -').strip()
        values = match.group(2).replace('\\', '')
        result = ', '.join([v.strip().strip('"').strip("'")
                           for v in values.split(',')])
        extracted.append([rule_desc, result])

    # Remove already matched parts to avoid duplicates
    text_cleaned = re.sub(pattern_list, '', text, flags=re.DOTALL)

    # Now extract single-value rules (not followed by [ ... ])
    for match in re.finditer(pattern_single, text_cleaned, re.DOTALL):
        rule_desc = match.group(1).strip().rstrip('= -').strip()
        value = match.group(2).strip().strip('.').strip()
        if value:
            extracted.append([rule_desc, value])

    return extracted


def create_text_pdf(data, filename):
    # Assumes data is a list of lists.
    pdf = MinimalPDF(filename)

    pdf.set_margin(40)
    pdf.set_font(9)
    pdf.draw_page_border()
    pdf.add_header("Keys and Values")

    # Calculate usable width dynamically based on margins
    usable_width = pdf.get_usable_width()
    # Define spacing between columns
    spacing = 10
    # Adjust column widths to fit within usable width, including spacing
    column_width = (usable_width - spacing) // 2
    columns = [
        (pdf.margin, column_width),
        (pdf.margin + column_width + spacing, column_width),
    ]
    divider = " | "

    # Rows
    for row in data:
        pdf.draw_row(row, columns, divider=divider)
        pdf.draw_separator(columns, divider=divider)

    # Set metadata
    pdf.set_metadata("Title", "Keys and Values PDF")
    pdf.set_metadata("PageCount", len(pdf.pages))

    return pdf.output()


def main():
    try:
        input_text = read_stdin()
        if not input_text:
            print("No input provided.")

        # Generate a timestamp for dynamic filenames
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

        rules = extract_rules(input_text)
        if rules:
            # pdf_filename = f"rules_{timestamp}.pdf"
            pdf_filename = "example.pdf"
            bin_pdf = create_text_pdf(rules, pdf_filename)
            with open(pdf_filename, "wb") as f:
                f.write(bin_pdf.getvalue())
            print(f"[Local Dev] Saved file: {pdf_filename}")
        else:
            print("No rules found in the input.")
    except Exception as e:
        print(f"Script failed: {str(e)}")


if __name__ == "__main__":
    main()
